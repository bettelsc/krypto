package math;

import java.lang.Math;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Random;

public class Calculation {
	
	public boolean isInRange(long aNumber) {
		
		if ((Math.pow(2, 32) < aNumber) && (aNumber < Math.pow(2, 64))) {
			
			return true;
		}
		return false;
	}

	public long calculateGGT(long aFirstNumber, long aSecondNumber)
	{

		while (aFirstNumber != aSecondNumber)
		{
			if (aFirstNumber > aSecondNumber)
			{
				aFirstNumber = aFirstNumber - aSecondNumber;
			}
			else
			{
				aSecondNumber = aSecondNumber - aFirstNumber;
			}
		}
		return aSecondNumber;
	}
	
	private ArrayList getListofPrimes(long aNumber) {
		
		ArrayList<Long> lPrimeNumbers = new ArrayList<>();
		
		int lPrimeFactor = 2;
		
		while (lPrimeFactor <= aNumber)
		{
			int iterator = 2;
            while((iterator < lPrimeFactor) && (lPrimeFactor % iterator !=0)) {
            	iterator++;
            }
            if(iterator == lPrimeFactor) {
                // p ist eine Primzahl
                while(aNumber % lPrimeFactor ==0) {
                    lPrimeNumbers.add((long) lPrimeFactor);
                    aNumber /= lPrimeFactor; // x = x / p;
                }
            }
            lPrimeFactor++;
		}

		return lPrimeNumbers;
	}
	
	/*public long calculatePhiFunction(long aNumber)
	{
		
	}*/
	
	private long aPowbModc(long a, long b, long c) 
	{
		long result = 1;
		
		for (int iterator = 0; iterator < b; iterator++)
		{
			result = result * a;
			result = result % c;
		}
		
		return result % c;
	}
	
	private long aMulbModc(long a, long b, long mod)
	{
		return BigInteger.valueOf(a).multiply(BigInteger.valueOf(b)).mod(BigInteger.valueOf(mod)).longValue();
	}

	public boolean millerRabinTest(long aNumber, int k)
	{
		long lPrimMinusOne = aNumber - 1;
		while (lPrimMinusOne % 2 == 0) { lPrimMinusOne = lPrimMinusOne/2; }
		
		Random lBase = new Random();
		
		for (int lIterator = 0; lIterator < k; lIterator++) {
			
			System.out.println("TEST");
			
			long lRandValue = Math.abs(lBase.nextLong());
			
			long laValue = lRandValue % (aNumber - 1) + 1, temp = lPrimMinusOne;
			
			long lModValue = aPowbModc(laValue, temp, aNumber);
			
			while (temp != aNumber - 1 && lModValue != 1 && lModValue != aNumber - 1)
			{
				lModValue = aMulbModc(lModValue, lModValue, aNumber);
				temp = temp * 2;
			}
			if (lModValue != aNumber - 1 && temp % 2 == 0) { return false; }
		}
		return true;
	}
	
	public boolean isPrime(long aNumber, int k)
	{
		if (aNumber <= 1)
		{
			return false;	
        } 
		else if (aNumber <= 3)
		{
            return true;
        } 
		else if (aNumber % 2 == 0)
		{
            return false;
        } 
		else
		{
            return millerRabinTest(aNumber, k);
        }
	}
	
	
	public static void main(String[] args)
	{
		Calculation calculation = new Calculation();
		
		ArrayList<Long> test;
		
		test = calculation.getListofPrimes(1000000L);
		
		for (int it = 0; it < test.size(); it++)
		{
			System.out.println(test.get(it));
		}
		/*int number = 15;
		
		boolean prime = calculation.isPrime(number, 1000);
		
		if (prime)
		{
			System.out.println(number + " is prime");
		}
		else
		{
			System.out.println(number + " is composite");
		}*/
		
		/*long x = calculation.calculateGGT(768786, 5676);
		
		System.out.println(x);
		*/
		/*if (calculation.isPrime(number))
		{	
			System.out.println("ITERATIVE: " + number + " ist eine Primzahl");
		}
		else 
		{
			System.out.println("ITERATIVE: " + number + " ist keine Primzahl");
		}
		
		if (calculation.isPrimeNumber(number, 2))
		{
			System.out.println("RECURSIVE: " + number + " ist eine Primzahl");
		}
		else
		{
			System.out.println("RECURSIVE: " + number + " ist keine Primzahl");
		}
		
		System.out.println(calculation.calculateGGT(4, 8));
		System.out.println(calculation.calculatePhiFunction(567890));*/
		
	}
	
	public void generateKeys(int aPrivateKey, int aPublicKey, int aPhiOfN)
	{	
	}
	
	
}
















